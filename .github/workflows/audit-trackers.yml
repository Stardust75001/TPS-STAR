name: "üîé Audit Trackers (GA4 / Meta / Ahrefs / Cloudflare / Sentry)"

on:
  workflow_dispatch:
    inputs:
      path:
        description: "Chemin √† tester (ex: /, /collections/all, /products/foo)"
        default: "/"
        required: true
  schedule:
    - cron: "15 3 * * *" # tous les jours √† 03:15 UTC

env:
  DOMAIN: ${{ secrets.TPS_DOMAIN }}
  EXPECT_GA4_ID: ${{ secrets.EXPECT_GA4_ID }}
  EXPECT_META_PIXEL_ID: ${{ secrets.EXPECT_META_PIXEL_ID }}
  EXPECT_AHREFS_VERIF: ${{ secrets.EXPECT_AHREFS_VERIF }}
  EXPECT_CF_TOKEN: ${{ secrets.EXPECT_CF_TOKEN }}
  EXPECT_SENTRY_DSN: ${{ secrets.EXPECT_SENTRY_DSN }}

jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: ‚úÖ Sanity check des variables
        run: |
          test -n "${DOMAIN}" || { echo "‚ùå secrets.TPS_DOMAIN manquant"; exit 1; }
          echo "üîó Domaine: ${DOMAIN}"

      - name: üîç T√©l√©charge la page cible
        id: fetch
        env:
          PATH_TO_TEST: ${{ github.event.inputs.path || '/' }}
        run: |
          URL="${DOMAIN}${PATH_TO_TEST}"
          echo "URL: $URL"
          http_code=$(curl -sIL -o /dev/null -w '%{http_code}' "$URL")
          echo "HTTP: $http_code"
          [ "$http_code" -ge 200 ] && [ "$http_code" -lt 400 ] || { echo "‚ùå Page non accessible ($http_code)"; exit 1; }
          curl -sL -A "TPS-Bot/1.0 (+audit-trackers)" "$URL" > page.html
          echo "page=page.html" >> "$GITHUB_OUTPUT"
          echo "url=$URL"       >> "$GITHUB_OUTPUT"

      - name: üß™ V√©rifie les trackers & pr√©pare le r√©sum√©/Slack
        id: check
        env:
          URL: ${{ steps.fetch.outputs.url }}
        run: |
          set -e
          fail=0
          LOG="audit.log"
          show(){ printf "%s\n" "$*" | tee -a "$LOG" ; }

          if [ -n "${EXPECT_GA4_ID}" ]; then
            grep -q "${EXPECT_GA4_ID}" page.html && show "‚úÖ GA4 (${EXPECT_GA4_ID})" || { show "‚ùå GA4 attendu non trouv√© (${EXPECT_GA4_ID})"; fail=1; }
          else
            grep -Eq 'gtag/js\?id=G-|G-[A-Z0-9]+' page.html && show "‚úÖ GA4 (pattern)" || show "‚ö†Ô∏è GA4 non d√©tect√© (pattern)"
          fi

          if [ -n "${EXPECT_META_PIXEL_ID}" ]; then
            grep -q "${EXPECT_META_PIXEL_ID}" page.html && show "‚úÖ Meta Pixel (${EXPECT_META_PIXEL_ID})" || { show "‚ùå Meta Pixel attendu non trouv√© (${EXPECT_META_PIXEL_ID})"; fail=1; }
          else
            grep -q "fbq(" page.html && show "‚úÖ Meta Pixel (pattern)" || show "‚ö†Ô∏è Meta Pixel non d√©tect√© (pattern)"
          fi

          if [ -n "${EXPECT_AHREFS_VERIF}" ]; then
            grep -Eq "<meta[^>]*name=['\"]ahrefs-site-verification['\"][^>]*content=['\"]${EXPECT_AHREFS_VERIF}['\"]" page.html \
              && show "‚úÖ Ahrefs verification (OK)" || { show "‚ùå Ahrefs verification manquante/incorrecte"; fail=1; }
          else
            grep -q "ahrefs-site-verification" page.html && show "‚úÖ Ahrefs verification (pattern)" || show "‚ö†Ô∏è Ahrefs verification non d√©tect√©e"
          fi

          if [ -n "${EXPECT_CF_TOKEN}" ]; then
            grep -q "cloudflareinsights.com/beacon.min.js" page.html && grep -q "${EXPECT_CF_TOKEN}" page.html \
              && show "‚úÖ Cloudflare Beacon (token OK)" || { show "‚ùå Cloudflare Beacon manquant ou token diff√©rent"; fail=1; }
          else
            grep -q "cloudflareinsights.com/beacon.min.js" page.html && show "‚úÖ Cloudflare Beacon (pattern)" || show "‚ö†Ô∏è Cloudflare Beacon non d√©tect√©"
          fi

          if [ -n "${EXPECT_SENTRY_DSN}" ]; then
            grep -q "${EXPECT_SENTRY_DSN}" page.html && show "‚úÖ Sentry (DSN trouv√©)" || { show "‚ùå Sentry DSN non trouv√©"; fail=1; }
          else
            grep -q "browser.sentry-cdn.com" page.html && show "‚úÖ Sentry (pattern)" || show "‚ö†Ô∏è Sentry non d√©tect√©"
          fi

          STATUS="‚úÖ Success"
          [ "$fail" -ne 0 ] && STATUS="‚ùå Fail"

          {
            echo "### ${STATUS} ‚Äì Audit Trackers"
            echo ""
            echo "*URL:* ${URL}"
            echo ""
            sed 's/^/- /' "$LOG"
          } >> "$GITHUB_STEP_SUMMARY"

          # Payload Slack (n√©cessite jq, pr√©sent sur ubuntu-latest)
          jq -n --arg status "$STATUS" --arg url "$URL" --arg text "$(cat "$LOG")" \
            '{ text: "[\($status)] Audit Trackers for \($url)",
               blocks: [
                 { "type":"section", "text":{"type":"mrkdwn","text":"*\($status)* Audit Trackers <\($url)|\($url)>" } },
                 { "type":"section", "text":{"type":"mrkdwn","text":"```\($text)```"} }
               ] }' > slack-temp.json

          exit $fail

      - name: üí¨ Notification Slack
        if: always()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload-file-path: slack-temp.json
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEB
